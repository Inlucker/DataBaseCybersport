\chapter{Существующие решения}
\section{Алгоритм RANSAC}
Алгоритм RANdom SAmple Consensus (RANSAC), предложенный Фишлером и Боллес \cite{RANSAC}, представляет собой стабильный метод оценки параметров модели на основе случайных выборок устойчевый к зашумлённости исходных данных (большая доля выбросов).

Часто возникает задача обработки данных, в которой необходимо определить параметры модели, которая должна удовлетворять исходным данным. Все исходные данные можно разделить на два типа: хорошие точки, удовлетворяющие модели, «не-выбросы» или «инлаеры» (англ. inlier) и ложные точки, шумы — случайные включения в исходные данные, «выбросы» или «аутлаеры» (англ. outlier).

RANSAC -- это итерационный алгоритм, который пределагает решения, используя минимальный набор данных, необходимых для оценки базовых параметров модели. Как указали Фишлер и Боллес, в отличие от обычных методов выборки, которые используют как можно больше данных для получения начального решения, а затем приступают к сокращению выбросов, RANSAC использует наименьший возможный набор и продолжает расширять его совместимыми точками из исходных данных.

На вход алгоритма поступают: 

\begin{enumerate}
	\item набор исходных данных $X$;
	\item функция $M$, позволяющая вычислить параметры $\theta$ модели $P$ по набору данных из $n$ точек;
	\item функция оценки $E$ соответствия точек полученной модели;
	\item порог $t$ для функции оценки;
	\item количество итераций метода $k$.
\end{enumerate}

Весь алгоритм состоит из одного цикла, каждую итерацию которого можно логически разделить на два этапа.

Первый этап — выбор точек и подсчёт модели:

\begin{itemize}
	\item из множества исходных точек $X$ случайным образом выбираются n различных точек;
	\item на основе выбранных точек вычисляются параметры $\theta$ модели $P$ с помощью функции $M$, построенную модель принято называть гипотезой.
\end{itemize}

Второй этап — проверка гипотезы:

\begin{itemize}
	\item для каждой точки проверяется её соответствие данной гипотезе с помощью функции оценки $E$ и порога $t$;
	\item каждая точка помечается инлаером или выбросом;
	\item после проверки всех точек, проверяется, является ли гипотеза лучшей на данный момент, и если является, то она замещает предыдущую лучшую гипотезу.
\end{itemize}

В конце работы цикла оставляется последняя лучшая гипотеза.

Результатом работы метода являются:

\begin{enumerate}
	\item параметры $\theta$ модели $P$; 
	\item точки исходных данных, помеченные инлаерами или выбросами.
\end{enumerate} 

Значение параметра $t$ должно быть определено в зависимости от конкретных требований, зависящих от данных, в большинстве случаев, только после экспериментальных оценок. Количество итераций $k$ выбирается достаточно большим, чтобы гарантировать, что по крайней мере один из наборов случайных выборок не содержит выбросов. Определяется оно методом теоретической оценки. Пусть $p$ — вероятность того, что алгоритм RANSAC на некоторой итерации, выбирая $n$ точек, на основе которых строится модель, возьмёт для расчётов из исходного набора данных только инлаеры. В такой ситуации построенная по данным точкам модель, с большой вероятностью будет достаточно точной. Исходя из этого, мы можем использовать вероятность $p$ для оценки точности работы алгоритма. Пусть $\omega$ -- ероятность выбора одного инлаера из общего числа точек, то есть $\omega=I/T$ -- количество инлаеров, $T$ -- общее число точек. В большинстве случаев доля инлаеров $\omega$ неизвестна до начала выполнения алгоритма, но практически всегда можно дать некоторую грубую оценку. Вероятность независимого выбора n инлаеров из исходных данных, в таком случае равна $q = C^n_I/C^n_T=I!(T-n)!/(T!(I-n)!)$, а вероятность того, что хотя бы одна точка из набора выброс, то есть что будет построена некорректная модель -- $(1-q)$. Вероятность того, что за $k$ итераций алгоритм ни разу не выберет $n$ инлаеров -- $(1−q)^k$, такая ситуация означает, что точная модель не будет построена, а вероятноть этого события равна $(1−p)$. Таким образом

$1-p=(1-q)^k$

Выразим необходимое нам количество итераций $k$:

$\displaystyle k = \frac{log(1-p)}{log(1-q)}$

Преимуществом алгоритма RANSAC является его способность дать надёжную оценку параметров модели, то есть возможность оценить параметры модели с высокой точностью, даже если в исходном наборе данных присутствует значительное количество выбросов. 

Одним из недостатков метода RANSAC является отсутствие верхней границы времени, необходимого для вычисления параметров модели. Если использовать в качестве некоторой границы времени максимальное число итераций, полученное решение может быть не оптимальным, а также существует очень малая вероятность, что ни одна модель не будет соответствовать исходным данным. Точная модель может быть определена с некоторой вероятностью, которая становится больше, чем больше итераций, которые используются. Ещё одним недостатком метода RANSAC является то, что для выполнения алгоритма необходимо задать конкретное пороговое значение. Наконец методом RANSAC можно определить только одну модель для определённого набора данных. Как и для любого подхода, предназначенного для одной модели, существует следующая проблема: когда в исходных данных присутствуют две (или более) модели, RANSAC может не найти ни одну.

Алгоритм RANSAC часто используется в компьютерном зрении, например, для решения задачи сопоставления изображений и оценки фундаментальной матрицы для определения параметров расположения камеры.

\section{Алгоритм SIFT}
Масштабно-инвариантная трансформация признаков (англ. scale-invariant feature transform, SIFT) это алгоритм компьютерного зрения, используемый для выявления и описания локальных признаков в изображениях. Этот алгоритм был опубликован Дэвидом Лоу в 1999 году и усовершенствован в 2004 году.

Сначала в SIFT извлекаются ключевые точки объектов из набора контрольных изображений \cite{Sift} и запоминаются в базе данных. Объект распознаётся в новом изображении путём сравнивания каждого признака из нового изображения с признаками из базы данных и нахождения признаков-кандидатов на основе евклидова расстояния между векторами признаков. Из полного набора соответствий в новом изображении отбираются поднаборы ключевых точек, которые наиболее хорошо согласуются с объектом по его местоположению, масштабу и ориентации. Определение подходящих блоков признаков осуществляется быстро с помощью эффективной реализации хеш-таблицы обобщённого преобразования Хафа. Каждый блок из 3 или более признаков, согласующийся с объектом и его положением, подлежит дальнейшей подробной проверке соответствия модели, и резко отклоняющиеся блоки отбрасываются. Наконец, вычисляется вероятность, что определённый набор признаков говорит о присутствии объекта, что даёт информацию о точности совпадения и числе возможных промахов. Объекты, которые проходят все эти тесты, могут считаться правильными с высокой степенью уверенности \cite{Sift2}. 

Лоу разбивает алгоритм SIFT на следующие четыре шага:

\begin{itemize}
	\item выявление экстремумов масштабного пространства: поиск ключевых (в рамках алгоритма SIFT) точек;
	\item локализация ключевых точек: отбрасывание точек с низкой контрастностью или расположенных не вдоль ребёр;
	\item определение направления: присваивание одного или нескольких направлений для каждой ключевой точки на основе локальных направлений градиента изображения;
	\item дескрипторы ключевых точек: вычисление дескриптора для каждой ключевой точки.
\end{itemize}

Ниже перечислены некоторые применения данного алгоритма:

\begin{itemize}
	\item распознавание объектов;
	\item определение местоположения и отслеживание техники/роботов;
	\item объеденение изображений;
	\item моделирование 3D-сцен, распознавание и трассировка;
	\item распознавания действий человека;
	\item анализ человеческого мозга в трёхмерных изображениях Магнитно-резонансной томографии.
\end{itemize}

\section{Алгоритм SURF}
Алгоритм SURF является улучшением алгоритма SIFT. Стандартная версия SURF в несколько раз быстрее, чем SIFT, и, как утверждают ее авторы \cite{SURF}, более устойчива к различным преобразованиям изображений.

Основным результатом алгоритма SURF являются обнаруженные ключевые точки, которые должны иметь следующие свойства: повторяемость (для
обеспечения возможности поиска такой же точки на следующем кадре); инвариантность к повороту и масштабу; уникальность.

\textbf{Алгоритм метода SURF.} Алгоритм работы SURF предусматривает выполнение следующих этапов:

\begin{itemize}
	\item масштабно-пространственное представление;
	\item расчет значений гессиана;
	\item поиск точек локальных максимумов;
	\item определение точки истинного максимума;
	\item определение ориентации опорной точки;
	\item формирование дескриптора опорной точки.
\end{itemize}

Обнаружение особых точек алгоритмом SURF основано на вычислении детерминанта матрицы Гессе (гессиана H) [7]. Значение гессиана используется для нахождения
локального минимума или максимума яркости изображения. В этих точках значение
гессиана достигает экстремума. Расчет производных происходит с помощью свертки
пикселей изображения с фильтрами, представленными на рисунке \ref{img:filtr}, где белые области соответствуют значению +1, черные -- значению -2 (на третьем фильтре -- значению -1), серые -- нулю \cite{SURF2}. 

\imgsc{H}{0.6}{filtr}{Фильтры, используемые в алгоритме}

Таким образом, в алгоритме SURF гессиан вычисляется следующим образом:

$det(h)=D_{xx}D_{yy}-(0,9D_{xy})^2$,

где $D_{xx}, D_{yy}, D_{xy}$ -- свертки по фильтрам (см. рис. \ref{img:filtr}); коэффициент 0,9 корректирует приближенный характер вычислений.

Следовательно, в качестве особых точек выбираются локальные максимумы гессианов, соответствующие локальным максимумам изменения градиента яркости. После нахождения точек локальных максимумов определяется точка истинного максимума гессиана. На этом шаге этап детектирования окончен. Дескриптор представляет собой массив из 64 чисел, которые определяют опорную точку. Дескриптор SURF инвариантен к масштабу и вращению.

Данный алгоритм можно использовать для таких задач, как распознавание объектов, регистрация изображений, классификация или 3D-реконструкция.

\section{Метод поиска соответствующих точек, использующий DSI}
Рассмотрим подробнее одномерный метод поиска
соответствующих точек, использующий DSI (\textit{disparity
space image}) \cite{6}
Пусть $s_i$ и $s'_i$ – соответствующие
$i$-е строки левого и правого изображений, $I(x,y)$ и
$I'(x,y)$ – соответствующие функции интенсивности.
Тогда параметр $DSI_i$ вычисляется как разность интенсивностей:

$DSI_i(x,d)=||I(x,i)-I'(x-d,i)||$,

где $N$ -- ширина картинки; $d_{max}$ -- максимальное допустимое расхождение на изображении; при этом выполняются условия $-d_{max} ≤ d ≤ d_{max}$ и $0 ≤ (x + d) ≤ N$.

Другим способом построения $DSI_i$ является вычисление величины, основанной на корреляции функций интенсивностей вокруг пикселей $(x,i)$ и $(x - d,i)$.
При этом размеры окна выбираются адаптивно (например, если точка находится на границе объектов, то
окно с центром в этой точке будет плохим, лучше
использовать окно, которое полностью принадлежит
одному объекту). Далее отбрасываем строки $DSI_i$,
которые соответствуют заведомо невозможным значениям $d$ (например, из условий, что пиксель на левом
изображении должен быть правее соответствующего
ему на правом, из условия $|d| ≤ d_{max}$) \cite{DSI}.

Задача сводится к поиску оптимального пути на
полученной двумерной матрице. При этом за каждый
тип движения назначается определенный штраф. Используются типы движения по горизонтали, вертикали и по диагонали. Последние два типа соответствуют
заслоненным областям (присутствующим только на
одном из изображений стереопары). Отметим, что
если некоторая поверхность на левом изображении
имеет ширину 9 пикселей, а на правом -- 3 пикселя, то
в этой терминологии трем пикселям из изображения
слева соответствуют 3 пикселя справа (это могут
быть, например, третий, шестой и восьмой), остальные 6 пикселей считаются заслоненными.

Задача решается методом динамического программирования. Если на изображении заранее известны GCP-точки (\textit{ground control points} -- точки, положение и соответствие которых мы можем определить
достаточно точно), то количество возможных путей
сокращается за счет использования следующего ограничения. Путь должен проходить так, чтобы он не
противоречил расстановке базовых GCP-точек. Возможны также многозначные GCP-точки, когда точке
одного изображения может соответствовать одна точка из небольшого набора вариантов на другом изображении.

\chapter{Сравнение}

По скольку алгоритм SURF базируется на методе SIFT, сравним их первыми.

На рисунке \ref{img:compare} представлены результаты метода SIFT и его сравнение с результатами методом SURF. Метод SIFT дает больше характерных точек и более точную их локализацию, однако имеет более медленное исполнение.

\imgsc{H}{1}{compare}{Сравнение результатов методов SIFT и SURF}

На рисунке изображены:

\begin{itemize}
	\item (слева) пример фотографии, полученной при аэрофотосъёмке;
	\item (справа) результат работы SIFT на данной фотографии;
	\item (по центру) результат работы SURF на данной фотографии \cite{comp1}.
\end{itemize}

Время работы SIFT в 2.5 раза больше, чем время работы SURF, однако SIFT при этом находит больше точек \cite{comp1}. Недостатки SURF проявляются на сильно размытых фотографиях \cite{comp2, comp3}, при сшивке разномасштабных фотографий и при смене угла обзора.

В общем случае алгоритм SIFT является более надежным, в то время как SURF - более быстрым.

На таблице \ref{tab} представлено сравнение рассмотренных методов поиска соответствующих  точек по производительности в реальном времени, точности локализации ключевых точек и по наличию шагу вычисления дескриптора.

\begin{table}[H]
	\begin{center}
		\caption{Сравнение алгоритмов поиска соответсвующих точек}
		\label{tab}
		""\newline
		\begin{tabular}{ | c | c | c | c | }
			\hline
			Алгоритм & Производ.  & Точность & Вычисление дескр. \\ \hline
			SIFT & средняя & высокая & да \\ \hline
			SURF & высокая & средняя & да \\ \hline
			Метод исп. DSI & высокая & средняя & нет \\ \hline
		\end{tabular}
	\end{center}
\end{table}

По сравнению с методом использующим DSI, алгоритмы SIFT и SURF используют базы данных, и поэтому могут найти объект на новом изображении, в то время когда первому методу всегда требуется 2 изображения. Кроме этого, SIFT и SURF позволяют не только представить трёхмерную модель объекта, но и распознать его.

Если же сравнивать алгоритмы SIFT и SURF, то наиболее предподчтиельным оказывается SURF, т.к. за небольшой объём вычислений, с более высокой скоростью получаются почти те же ключевые точки, как у метода SIFT

Алгоритм RANSAC исключен из сравнения, т.к. он решает другую задачу. Алгоритм RANSAC можно использовать в совокупности с одним из выше перечисленных для фильтрации полученных сопоставлений, потому что иногда сопоставляемые точки могут быть соотнесены некорректно, а RANSAC отсеивает «выпадающие» (outliers) из статистики точки.

